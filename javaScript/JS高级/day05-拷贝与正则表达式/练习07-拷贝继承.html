<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>
        //对象的拷贝继承

        //方式一（传递指向，堆中没有开辟空间）：
        var obj1={
            name:"小米",
            age:18,
            eat:function () {
                console.log("吃！");
            }
        };
        var obj2=obj1; //对象间传递的是引用（地址）--仅仅改变了地址的指向，堆的内存中并没有开辟obj2的空间
        console.dir(obj2);

        //方式二（浅拷贝）：
        var obj3={
            name:"小红",
            age:38,
            eat:function () {
                console.log("吃饭！");
            }
        };
        var obj4={}; //堆中开辟了空间
        //for-in遍历对象
        for(var key in obj3){
          obj4[key]=obj3[key];
        }
        console.dir(obj4);


        // //构造函数的拷贝继承---错误案例--原型对象中并没有添加共享数据
        // function Person(name,sex,age) {
        //     this.name=name;
        //     this.sex=sex;
        //     this.age=age;
        //     this.play=function () {
        //         console.log("玩游戏！");
        //     }
        // }
        // var obj5={};
        // for(var key in Person.prototype){
        //     obj5[key]=Person.prototype[key];
        // }
        // console.dir(obj5);


        //构造函数的拷贝继承--构造函数的原型对象拷贝继承（浅拷贝）---原型对象中的共享数据
        function Person() {

        }
        Person.prototype.name="小李";
        Person.prototype.sex="男";
        Person.prototype.age=36;
        Person.prototype.play=function () {
            console.log("玩游戏！");
        };
        var obj5={};
        for(var key in Person.prototype){
            obj5[key]=Person.prototype[key];
        }
        console.dir(obj5);
        obj5.play();
        //Person的构造中有原型prototype属性,prototype属性就是一个对象,那么里面的age,sex,height,play都是该对象中的属性或者方法

    </script>
</body>
</html>
