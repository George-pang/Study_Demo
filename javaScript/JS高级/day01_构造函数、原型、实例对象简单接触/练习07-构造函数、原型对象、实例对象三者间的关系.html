<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

       //通过构造函数实例对象,并初始化
       var arr=new Array(10,20,30,40);
       //join是方法,实例对象调用的方法
       arr.join("|");
       console.dir(arr);
       //join方法在实例对象__proto__原型
       console.log(arr.__proto__==Array.prototype);

</script>
<script>
    //构造函数
    function Person(age,sex) {
        this.age=age;
        this.sex=sex; //this指当前实例对象
    }

    //通过构造函数的原型对象属性,添加方法---原型的作用之一：共享数据，节省内存空间
    Person.prototype.eat=function () {     //对象可以作为另一个对象的属性存在
      console.log("我要吃肉肉！");
    };

    //通过构造函数实例化对象，并初始化
    var per1=new Person(18,"sex");
    //调用原型对象中的方法
    per1.__proto__.eat();   //因为实例对象的__proto__对象属性指向构造函数中的原型对象，所以原型对象中的方法可以直接被实例对象访问
    //因为__proto__不是个标准属性--IE8不支持,所以可省略
    per1.eat();  //省略写法

    console.dir(Person);
    console.dir(per1);

    //总结：
    /*
    * 1、构造函数中有个prototype属性，该属性就是构造函数的原型对象
    * 2、构造函数的原型对象中有个constructor属性(构造器)，指向所在原型对象所在的构造函数
    * 3、通过构造函数创建实例对象，实例对象中有个__proto__属性（非标准属性、也是个对象）,该属性指向构造函数的prototype对象
    * 4、构造函数的原型对象（prototype对象）中的方法可以直接被实例对象访问---per.__proto__.eat(),简写：per.eat()
    *
    * */

</script>
</body>
</html>